#!/usr/bin/python
import sys
import numpy as np
import time
import polar_codes_generator as polar
import utils
import matrix_codes as mat_gen
import flip_codes as flip
################################################################################ python ber_bler_calculator.py 8 4 BER 2000

### ============ Uncoded ======================================
def uncoded(metric, k=4, nb_pkts = 100, graph = 'BER'):
  print('-------------------Uncoded-----------------------------')
  key = f"Uncode"
  N = k
  U_k = utils.symbols_generator(k)  # all possible messages
  if graph == 'BLER':
    metric[key] = utils.block_error_probability(N,k,U_k,e0,e1)
  else:
    metric[key] = utils.bit_error_rate(k,U_k,nb_pkts,e0,e1,False)
    # print(BER[key])

### ============ BCH ======================================
def bch_codes(metric, N=8, k=4, nb_pkts = 100, graph = 'BER'):
  print('-------------------BCH Code-----------------------------')
  G = mat_gen.matrix_codes(N, k, 'bch')
  if G != []:
    for key in [0]:
      # print('G = ', np.array(G))
      k = len(G)
      N = len(G[1])
      U_k = utils.symbols_generator(k)  # all possible messages
      C = utils.matrix_codes(U_k, k, G, N)
      print('k ',k,'N ',N)
      if graph == 'BLER':
        metric[f"BCH({key})"] = utils.block_error_probability(N,k,C,e0,e1)
      else:
        metric[f"BCH({key})"] = utils.bit_error_rate(k,C,nb_pkts,e0,e1)
        # print(metric[f"BCH({key})"])

### ============ Linear codes======================================
def linear_codes(metric, N=8, k=4, nb_pkts = 100, graph = 'BER'):
  print('-------------------Linear Code-----------------------------')
  for key in ['BKLC']:
    print(key)
    G = mat_gen.matrix_codes(N, k, key)
    if G != []:
      # print('G = ', np.array(G))
      k = len(G)
      N = len(G[1])
      U_k = utils.symbols_generator(k)  # all possible messages
      C = utils.matrix_codes(U_k, k, G, N)
      print(np.array(C))
      print('k ',k,'N ',N)
      if graph == 'BLER':
        metric[key] = utils.block_error_probability(N,k,C,e0,e1)
      else:
        metric[key] = utils.bit_error_rate(k,C, nb_pkts,e0,e1)
        # print(metric[key])

### ============ Polar codes======================================
def polar_codes(metric, N=8, k=4, nb_pkts = 100, graph = 'BER',channel='BSC'):
  print('-------------------Polar Code-----------------------------')
  for key in [0.1]:
    G, infoBits = polar.polar_generator_matrix(N,k, channel, key)
    k = len(G)
    N = len(G[1])
    U_k = utils.symbols_generator(k)  # all possible messages
    C = utils.matrix_codes(U_k, k, G, N)
    # print('Polar codebook', np.array(C))
    if graph == 'BLER':
      metric[f"Polar({key})"] = utils.block_error_probability(N,k,C,e0,e1)
    else:
      metric[f"Polar({key})"] = utils.bit_error_rate(k,C,nb_pkts,e0,e1)
      # print(metric[f"Polar({key})"])

### ============ Polar codes======================================
def flip_codes(metric, N=8, k=4, nb_pkts = 100, graph = 'BER',channel='BSC'):
  print('-------------------Flip Code-----------------------------')
  key = '2,4,6'
  all_C = flip.codebook_generator_k4(N)
  C = all_C[2,4,6]
  print('Flip codebook', np.array(C))
  if graph == 'BLER':
    metric[f"Flip({key})"] = utils.block_error_probability(N,k,C,e0,e1)
  else:
    metric[f"Flip({key})"] = utils.bit_error_rate(k,C,nb_pkts,e0,e1)
    # print(metric[f"Flip({key})"])

### ============ Linear codes + Mapping======================================
def linear_codes_mapping(metric, N=8, k=4, nb_pkts = 100, graph = 'BER'):
  print('-------------------Linear Code + Mapping-----------------------------')
  G = mat_gen.matrix_codes(64,k,'linear')
  if G!= []:
    for key in [0.55]:
      k = len(G)
      Nt = len(G[1])
      t = int(Nt/N)
      U_k= utils.symbols_generator(k)  # all possible messages
      X_m = utils.symbols_generator(t)  # all possible symbol sequences
      C = utils.matrix_codes(U_k, k, G, Nt)
      nx = 2**t*key
      # print('nx', nx, 't', t)
      x = utils.mapping(C, X_m, t, nx) #codebook after mapping
      N = len(x[1])

      if graph == 'BLER':
        metric[f"L+M({key})"] = utils.block_error_probability(N,k,x,e0,e1)
      else:
        metric[f"L+M({key})"] = utils.bit_error_rate(k,x,nb_pkts,e0,e1)
        # print(metric[f"L+M({key})"])

### ============ Polar codes + Mapping ======================================
def polar_codes_mapping(metric, N=8, k=4, nb_pkts = 100, graph = 'BER',channel='BSC'):
  print('-------------------Polar Codes + Mapping-----------------------------')
  cont = 2
  if channel == 'AWGN':
    design_parameter = np.linspace(0.0, 10, cont)
  else:
    design_parameter = np.linspace(0.0001, 0.1, cont)

  for key in [0.5]:
    e_design = 0.1
    # print('===============Design================',key)
    G,infoBits = polar.polar_generator_matrix(64, k, channel, e_design)

    k = len(G)
    Nt = len(G[1])
    t = int(Nt /N)
    U_k = utils.symbols_generator(k)  # all possible messages
    X_m = utils.symbols_generator(t)  # all possible symbol sequences
    C = utils.matrix_codes(U_k, k, G, Nt)

    nx = 2**t*key
    # print('nx', nx, 't', t)
    x = utils.mapping2(C, X_m, t, nx)
    N = len(x[1])
    if graph == 'BLER':
      metric[f"P({e_design})+M({key})"] = utils.block_error_probability(N,k,x,e0,e1)
    else:
      metric[f"P({e_design})+M({key})"] = utils.bit_error_rate(k,x,nb_pkts,e0,e1)
      # print(metric[f"P({e_design})+M({key})"])

### ============ Polar codes Integrated Scheme ======================================
def integrated_scheme(metric, N=8, k=4, nb_pkts = 100, graph = 'BER',channel='BSC'):
  print('-------------------Integrated Scheme Code-----------------------------')
  for key in [0.5]:
    G, infoBits = polar.polar_generator_matrix(64, k, channel, 0.1)
    k = len(G)
    Nt = len(G[1])
    t = int(Nt / N)

    U_k = utils.symbols_generator(k)  # all possible messages
    C = utils.integrated_function(infoBits,U_k,k,Nt,-1)

    X_m = utils.symbols_generator(t)  # all possible symbol sequences
    nx = 2 ** t * key
    # print('nx', nx, 't', t)
    x = utils.mapping(C, X_m, t, nx)
    N = len(x[1])
    if graph == 'BLER':
      metric[f"Int_P({key})"] = utils.block_error_probability(N, k, C,e0,e1)
    else:
      metric[f"Int_P({key})"] = utils.bit_error_rate(k,x,nb_pkts,e0,e1)
      # print(metric[f"Int_P({key})"])

### ============ Polar codes + NN-decoder ======================================
def polar_codes_NN(metric, N=8, k=4, nb_pkts = 100, graph = 'BER',channel='BSC'):
  print('-------------------Polar Code + NN decoder -----------------------------')
  key = 'NN_dec'
  G,infoBits = polar.polar_generator_matrix(N, k, channel, 0.1)
  # print('G = ', np.array(G))
  k = len(G)
  N = len(G[1])
  U_k = utils.symbols_generator(k)  # all possible messages
  C = utils.matrix_codes(U_k, k, G, N)
  print('k ', k, 'N ', N)
  if graph == 'BLER':
    metric[key] = utils.block_error_probability(N, k, C, e0, e1)
  else:
    metric[key] = utils.bit_error_rate_NN(N, k, C, nb_pkts, e0, e1, channel)
    # print(metric[key])

### ============ Linear codes======================================
def linear_codes_NN(metric, N=8, k=4, nb_pkts = 100, graph = 'BER',channel='BSC'):
  print('-------------------Linear Code + NN-----------------------------')
  for key in ['BKLC']:
    print(key)
    G = mat_gen.matrix_codes(N, k, key)
    if G != []:
      # print('G = ', np.array(G))
      k = len(G)
      N = len(G[1])
      U_k = utils.symbols_generator(k)  # all possible messages
      C = utils.matrix_codes(U_k, k, G, N)
      # print('codebook',np.array(C))
      # print(np.array(C))
      print('k ',k,'N ',N)
      if graph == 'BLER':
        metric['BKLC-NN'] = utils.block_error_probability(N,k,C,e0,e1)
      else:
        metric['BKLC-NN'] = utils.bit_error_rate_NN(N, k, C, nb_pkts, e0, e1, channel)
        print(metric['BKLC-NN'])

### ============ NN-autoencoder ======================================
def autoencoder_NN(metric, N=8, k=4, nb_pkts = 100, graph = 'BER',channel='BSC'):
  print('------------------- NN-autoencoder -----------------------------')
  key = 'NN_auto'
  C = utils.NN_encoder(k,N)
  # print(np.array(C))
  print('k ', k, 'N ', N)
  if graph == 'BLER':
    metric[key] = utils.block_error_probability(N, k, C, e0, e1)
  else:
    print("NN BER")
    t = time.time()
    metric[key] = utils.bit_error_rate_NN(N, k, C, nb_pkts, e0, e1, channel)
    t = time.time() - t
    print(f"NN time = {t}s ========================")

    print("MAP BER")
    t = time.time()
    metric['MAP_dec'] = utils.bit_error_rate(k, C, nb_pkts, e0, e1)
    t = time.time() - t
    print(f"MAP time = {t}s =======================")


### ============ Figures ======================================

def saved_results(metric,N=8, k=4, graph = 'BER'):
  if graph == 'BER':
    if N == 16:
      if k == 4:
        metric['BKLC-NN-std'] = {0.001: [0.0], 0.0016378937069540646: [0.0, 0.0], 0.0026826957952797246: [0.0, 0.0], 0.004393970560760791: [0.0, 0.0], 0.0071968567300115215: [0.0, 0.0], 0.011787686347935873: [0.0, 0.0], 0.019306977288832496: [0.0, 5e-05], 0.03162277660168379: [0.0, 0.0003], 0.0517947467923121: [0.0, 0.0014375], 0.08483428982440717: [0.0002125, 0.0079125], 0.13894954943731375: [0.0021625, 0.0409125], 0.22758459260747887: [0.0114875, 0.1598375], 0.3727593720314938: [0.0589, 0.3886125], 0.6105402296585326: [0.227825], 0.999: [0.499325]}
        # metric['BKLC-NN-e0-0.25'] =  {0.001: [0.0], 0.0016378937069540646: [0.0, 0.0], 0.0026826957952797246: [0.0, 0.0], 0.004393970560760791: [0.0, 0.0], 0.0071968567300115215: [0.0, 4.1666666666666665e-05], 0.011787686347935873: [0.0, 5.833333333333333e-05], 0.019306977288832496: [0.0, 0.00013333333333333334], 0.03162277660168379: [0.0, 0.0008666666666666666], 0.0517947467923121: [2.5e-05, 0.00395], 0.08483428982440717: [0.000175, 0.017641666666666667], 0.13894954943731375: [0.0010583333333333334, 0.06320833333333334], 0.22758459260747887: [0.007933333333333334, 0.19488333333333333], 0.3727593720314938: [0.047391666666666665, 0.3892833333333333], 0.6105402296585326: [0.21513333333333334], 0.999: [0.5002416666666667]}
      elif k == 8:
        metric['Polar(0.1)'] = {0.001: [0.0], 0.001995262314968879: [0.0, 0.0], 0.003981071705534973: [0.0, 0.00025], 0.007943282347242814: [0.000625, 0.0], 0.015848931924611134: [0.000625, 0.006625], 0.03162277660168379: [0.00625, 0.022875], 0.0630957344480193: [0.01375, 0.07925], 0.12589254117941676: [0.0475, 0.18], 0.25118864315095796: [0.13975, 0.3805], 0.501187233627272: [0.315375], 0.999: [0.502125]}
        # metric['BCH(0)'] = {0.001: [0.000375], 0.001995262314968879: [0.0, 0.0], 0.003981071705534973: [0.0, 0.00025], 0.007943282347242814: [0.000125, 0.001375], 0.015848931924611134: [0.000625, 0.003625], 0.03162277660168379: [0.002125, 0.011875], 0.0630957344480193:[0.005375, 0.045875], 0.12589254117941676: [0.028375, 0.141875], 0.25118864315095796: [0.092375, 0.29925], 0.501187233627272: [0.268], 0.999: [0.499875]}
        metric['BKLC'] = {0.001: [0.0], 0.001995262314968879: [0.0, 0.0], 0.003981071705534973: [0.0, 0.0], 0.007943282347242814: [0.0, 0.0], 0.015848931924611134: [0.0, 0.000375], 0.03162277660168379: [0.0, 0.004125], 0.0630957344480193: [0.00225, 0.024875], 0.12589254117941676: [0.011, 0.104], 0.25118864315095796: [0.05775, 0.290375], 0.501187233627272: [0.234], 0.999: [0.50075]}
        metric['BKLC-NN-std'] ={0.001: [0.0], 0.1009: [0.0094125, 0.0644], 0.2008: [0.0505, 0.223], 0.3007: [0.1182125, 0.34436875], 0.4006: [0.1953375, 0.4312], 0.5005: [0.2701], 0.6004: [0.3314], 0.7003: [0.38294375], 0.8002: [0.4245], 0.9001: [0.46371875], 0.999: [0.4988375]}
    # {0.001: [0.0], 0.1009: [0.009341666666666667, 0.06589166666666667], 0.2008: [0.049341666666666666, 0.22460833333333333], 0.3007: [0.11985833333333333, 0.34779166666666667], 0.4006: [0.19768333333333332, 0.42880833333333335], 0.5005: [0.27270833333333333], 0.6004: [0.33234166666666665], 0.7003: [0.38221666666666665], 0.8002: [0.42728333333333335], 0.9001: [0.4660416666666667], 0.999: [0.49935833333333335]}
    elif N == 8:
      if k == 4:
        metric['BKLC-NN-std'] = {0.001: [0.0], 0.001995262314968879: [0.0, 0.0], 0.003981071705534973: [0.0, 0.0], 0.007943282347242814: [0.0, 0.0], 0.015848931924611134: [0.0, 0.0], 0.03162277660168379: [0.0, 0.000175], 0.0630957344480193: [5e-05, 0.002325], 0.12589254117941676: [0.00135, 0.029725], 0.25118864315095796: [0.016475, 0.1969], 0.501187233627272: [0.13465], 0.999: [0.499325]}

    return metric
  elif graph == 'BLER':
    if N == 16:
      if k == 4:
        metric = {'Uncode': {0.001: [0.003994003998999962], 0.001995262314968879: [0.005977080666546231, 0.007957194586922567], 0.003981071705534973: [0.009924988552464376, 0.01582944536234132], 0.007943282347242814: [0.01776694849809124, 0.031396555750146105], 0.015848931924611134: [0.033274420643965574, 0.061904457030626414], 0.03162277660168379: [0.06366647340736609, 0.1206165975131418], 0.0630957344480193: [0.12215968034298319, 0.22948541319954663], 0.12589254117941676: [0.23063789666190093, 0.4162064337867246], 0.25118864315095796: [0.4167453026090392, 0.6855948219086256], 0.501187233627272: [0.6854351958031142], 0.999: [0.9375]},
                'Polar(0.1)': {0.001: [4.663024411044603e-10], 0.001995262314968879: [1.7091809079161635e-09, 7.350769215541675e-09], 0.003981071705534973: [9.438784642767928e-09, 1.1522459630874948e-07], 0.007943282347242814: [6.951947639777245e-08, 1.7860678352965564e-06], 0.015848931924611134: [6.66037556995569e-07, 2.7069244676325432e-05], 0.03162277660168379: [6.242399077871497e-06, 0.0003917722801248802], 0.0630957344480193: [7.59253863791276e-05, 0.00514875982608598], 0.12589254117941676: [0.0010230996422875283, 0.05493238665145861], 0.25118864315095796: [0.01404410487288088, 0.3679267771663388], 0.501187233627272: [0.17241850492532151], 0.999: [0.9375]},
                'BCH(0)': {0.001: [4.873073056188559e-10], 0.001995262314968879: [2.255736708534073e-09, 7.673217394810194e-09], 0.003981071705534973: [1.571178764869785e-08, 1.2017159656263487e-07], 0.007943282347242814: [1.0079732470913427e-07, 1.8595979613955649e-06], 0.015848931924611134: [7.784285169787353e-07, 2.8092172501659185e-05], 0.03162277660168379: [7.991371429483252e-06, 0.0004041636357504652], 0.0630957344480193: [0.00010192214992688076, 0.005259002462390527], 0.12589254117941676: [0.0012593338957352929, 0.05535283225745713], 0.25118864315095796: [0.01738150257685478, 0.36695327549905676], 0.501187233627272: [0.19896145469122506], 0.999: [0.9375]},
                'BKLC': {0.001: [4.870062131345776e-10], 0.001995262314968879: [1.9987611565852603e-09, 7.673194857282795e-09], 0.003981071705534973: [1.1444556635709091e-08, 1.2017225348159855e-07], 0.007943282347242814: [8.425259179212219e-08, 1.8595988041658629e-06], 0.015848931924611134: [7.777258022034772e-07, 2.8092171812210687e-05], 0.03162277660168379: [7.703228494082559e-06, 0.00040416363593032134], 0.0630957344480193: [9.362370801957454e-05, 0.005259002462257412], 0.12589254117941676: [0.0012523783397200283, 0.05535283225738796], 0.25118864315095796: [0.016975059456702746, 0.366953275499072], 0.501187233627272: [0.19789749211702912], 0.999: [0.9375]},
                'L+M(0.55)': {0.001: [2.6246691446907278e-06], 0.001995262314968879: [4.804419578396946e-06, 1.0449011468849356e-05], 0.003981071705534973: [1.1028153132919272e-05, 4.16140838627177e-05], 0.007943282347242814: [3.100911487796676e-05, 0.0001660399719476402], 0.015848931924611134: [0.00010181792993968486, 0.0006677530334779913], 0.03162277660168379: [0.00037324974073627004, 0.0027677607704662543], 0.0630957344480193: [0.0014983587572872104, 0.012609721529144524], 0.12589254117941676: [0.006346006573917817, 0.06842031429361506], 0.25118864315095796: [0.02999478148492607, 0.3662827625965799], 0.501187233627272: [0.19850518359097646], 0.999: [0.9375]},
                'P(0.1)+M(0.5)': {0.001: [1.5287956189879992e-06], 0.001995262314968879: [2.5750097986110276e-06, 6.200693034696947e-06], 0.003981071705534973: [5.210557184054387e-06, 2.5598520945857572e-05], 0.007943282347242814: [1.321196431935956e-05, 0.00010922160595705499], 0.015848931924611134: [3.6361041869326094e-05, 0.0004936812836560112], 0.03162277660168379: [0.00012159278219425751, 0.0024404756123660443], 0.0630957344480193: [0.0005035907812881435, 0.01346199658525049], 0.12589254117941676: [0.002743351151984985, 0.07905293240305267], 0.25118864315095796: [0.0176670628846054, 0.3919357253480511], 0.501187233627272: [0.1511403402786069], 0.999: [0.9375]},
                'Int_P(0.5)': {0.001: [0.7500000000175159], 0.001995262314968879: [0.7500000000179664, 0.7500000002760664], 0.003981071705534973: [0.7500000000313118, 0.7500000043541152], 0.007943282347242814: [0.7500000004513712, 0.750000068349369], 0.015848931924611134: [0.7500000134701702, 0.7500010627263365], 0.03162277660168379: [0.7500000205733874, 0.750016206264416], 0.0630957344480193: [0.7500004091634982, 0.7502374684307448], 0.12589254117941676: [0.7500078639474461, 0.7531917176614641], 0.25118864315095796: [0.7501054167754733, 0.7845456541073789], 0.501187233627272: [0.7529793520801775], 0.999: [0.9375]},
                'Int_P(0.9)': {0.001: [0.7500000000175159], 0.001995262314968879: [0.7500000000179664, 0.7500000002760664], 0.003981071705534973: [0.7500000000313118, 0.7500000043541152], 0.007943282347242814: [0.7500000004513712, 0.750000068349369], 0.015848931924611134: [0.7500000134701702, 0.7500010627263365], 0.03162277660168379: [0.7500000205733874, 0.750016206264416], 0.0630957344480193: [0.7500004091634982, 0.7502374684307448], 0.12589254117941676: [0.7500078639474461, 0.7531917176614641], 0.25118864315095796: [0.7501054167754733, 0.7845456541073789], 0.501187233627272: [0.7529793520801775], 0.999:[0.9375]}}

      elif k == 8:
        metric = {
                # 'Uncoded': {0.001: [0.0018375], 0.001995262314968879: [0.00208125, 0.00203125], 0.003981071705534973: [0.0029375, 0.00398125], 0.007943282347242814: [0.0049375, 0.00785], 0.015848931924611134: [0.0091, 0.015825], 0.03162277660168379: [0.0171375, 0.032675], 0.0630957344480193: [0.03314375, 0.0641625], 0.12589254117941676: [0.06451875, 0.12606875], 0.25118864315095796: [0.12760625, 0.25244375], 0.501187233627272: [0.251975], 0.999: [0.50184375]},
                # 'Polar': {0.001: [5.625e-05], 0.001995262314968879: [0.00013125, 0.000125], 0.003981071705534973: [0.000175, 0.00043125], 0.007943282347242814: [0.00063125, 0.0016625], 0.015848931924611134: [0.00165, 0.005325], 0.03162277660168379: [0.00366875, 0.021475], 0.0630957344480193: [0.0136625, 0.0685], 0.12589254117941676: [0.04769375, 0.1856], 0.25118864315095796: [0.1312375, 0.37719375], 0.501187233627272: [0.32815], 0.999: [0.49995625]},
                # 'BCH': {0.001: [8.75e-05], 0.001995262314968879: [6.25e-05, 5e-05], 0.003981071705534973: [0.00013125, 0.00026875], 0.007943282347242814: [0.00023125, 0.00080625], 0.015848931924611134: [0.00044375, 0.00365], 0.03162277660168379: [0.0018125, 0.01293125], 0.0630957344480193: [0.007025, 0.0442875], 0.12589254117941676: [0.0258375, 0.1336625], 0.25118864315095796: [0.09119375, 0.2986625], 0.501187233627272: [0.264575], 0.999: [0.50145]},
                # 'BKLC': {0.001: [1.875e-05], 0.001995262314968879: [0.0, 0.0], 0.003981071705534973: [0.0, 0.0], 0.007943282347242814: [2.5e-05, 0.00011875], 0.015848931924611134: [8.125e-05, 0.00055], 0.03162277660168379: [0.00045625, 0.00354375], 0.0630957344480193: [0.001875, 0.02281875], 0.12589254117941676: [0.010375, 0.10095], 0.25118864315095796: [0.05811875, 0.2904875], 0.501187233627272: [0.241625], 0.999: [0.49931875]},
                # 'L+M': {0.001: [0.00028125], 0.001995262314968879: [0.0002875, 0.0004875], 0.003981071705534973: [0.00031875, 0.00074375], 0.007943282347242814: [0.00074375, 0.00180625], 0.015848931924611134: [0.0014875, 0.0053125], 0.03162277660168379: [0.00279375, 0.01525625], 0.0630957344480193: [0.00936875, 0.0501125], 0.12589254117941676: [0.0276875, 0.16263125], 0.25118864315095796: [0.09575, 0.36948125], 0.501187233627272: [0.30030625], 0.999: [0.50085]},
                # 'P+M': {0.001: [0.02591875], 0.001995262314968879: [0.026875, 0.0267875], 0.003981071705534973: [0.02643125, 0.02705625], 0.007943282347242814: [0.029975, 0.03229375], 0.015848931924611134: [0.0315, 0.040325], 0.03162277660168379: [0.0385125, 0.05834375], 0.0630957344480193: [0.0501875, 0.10281875], 0.12589254117941676: [0.0769625, 0.20686875], 0.25118864315095796: [0.15371875, 0.39544375], 0.501187233627272: [0.32949375], 0.999: [0.49814375]},
                # 'Int': {0.001: [0.12483125], 0.001995262314968879: [0.1248375, 0.1267125], 0.003981071705534973: [0.124425, 0.1256], 0.007943282347242814: [0.1253, 0.126575], 0.015848931924611134: [0.1259125, 0.1279125], 0.03162277660168379: [0.1276875, 0.13408125], 0.0630957344480193: [0.1288375, 0.155725], 0.12589254117941676: [0.14586875, 0.2274], 0.25118864315095796: [0.19374375, 0.3874875], 0.501187233627272: [0.337825], 0.999: [0.50081875]}
        }
    elif N == 8:
      if k == 4:
        metric = {
                # 'Uncoded': {0.001: [0.003994003998999962], 0.001995262314968879: [0.005977080666546231, 0.007957194586922567], 0.003981071705534973: [0.009924988552464376, 0.01582944536234132], 0.007943282347242814: [0.01776694849809124, 0.031396555750146105], 0.015848931924611134: [0.033274420643965574, 0.061904457030626414], 0.03162277660168379: [0.06366647340736609, 0.1206165975131418], 0.0630957344480193: [0.12215968034298319, 0.22948541319954663], 0.12589254117941676: [0.23063789666190093, 0.4162064337867246], 0.25118864315095796: [0.4167453026090392, 0.6855948219086256], 0.501187233627272: [0.6854351958031142], 0.999: [0.9375]},
                # 'Polar':  {0.001: [2.0930104921101922e-05], 0.001995262314968879: [4.170985086604517e-05, 8.304813753134965e-05], 0.003981071705534973: [0.00010374382967748286, 0.0003284371599558966], 0.007943282347242814: [0.0003093936845051104, 0.0012903426820463082], 0.015848931924611134: [0.0010452374886334992, 0.005002828092101952], 0.03162277660168379: [0.0038025282255498283, 0.01888878413491335], 0.0630957344480193: [0.014334037680204914,0.06760162311202733], 0.12589254117941676: [0.05184532653776541, 0.21701403305161693], 0.25118864315095796: [0.16909150572799436, 0.5580107458703938], 0.501187233627272: [0.4907785921994958], 0.999: [0.9375]},
                # 'BCH': {0.001: [2.0930104917771253e-05], 0.001995262314968879: [4.686627713423874e-05, 8.304813753312601e-05], 0.003981071705534973: [0.0001291809046302106, 0.00032843715995367617], 0.007943282347242814: [0.00041369298568405544, 0.0012903426820485286], 0.015848931924611134: [0.0014491383091672638, 0.005002828092105838], 0.03162277660168379: [0.005291917896825038, 0.018888784134911463], 0.0630957344480193: [0.015436204839802015, 0.06760162311202789], 0.12589254117941676: [0.05219256548064566, 0.2170140330516156], 0.25118864315095796: [0.17326993904123578, 0.5580107458703947], 0.501187233627272: [0.5030267527221204], 0.999: [0.9375]},
                # 'BKLC': {0.001: [2.0930104921101922e-05], 0.001995262314968879: [4.170985086604517e-05, 8.304813753134965e-05], 0.003981071705534973: [0.00010374382967748286, 0.0003284371599558966], 0.007943282347242814: [0.0003093936845051104, 0.0012903426820463082], 0.015848931924611134: [0.0010452374886334992, 0.005002828092101952], 0.03162277660168379: [0.0038025282255498283, 0.01888878413491335], 0.0630957344480193: [0.014334037680204914, 0.06760162311202733], 0.12589254117941676: [0.05184532653776541, 0.21701403305161693], 0.25118864315095796: [0.16909150572799436, 0.5580107458703938], 0.501187233627272: [0.4907785921994958], 0.999: [0.9375]},
                # 'L+M': {0.001: [0.0019431064481476579], 0.001995262314968879: [0.0024495295763085068, 0.0038880669854024497], 0.003981071705534973: [0.0034717521059396406, 0.007801308144549934], 0.007943282347242814: [0.005558110549595985, 0.015735762651908458], 0.015848931924611134: [0.009904627910614971, 0.03204703178603696], 0.03162277660168379: [0.019294792547481454, 0.06631832071323585], 0.0630957344480193: [0.03868852476446627, 0.14016410664955914], 0.12589254117941676: [0.08406121988508519, 0.2991765639906231], 0.25118864315095796: [0.197107344422361, 0.6016296899477842], 0.501187233627272: [0.4806917493801961], 0.999: [0.9375]},
                # 'P+M': {0.001: [0.0020049840050305745], 0.001995262314968879: [0.002637158674338891, 0.004010302976008795], 0.003981071705534973: [0.003918263756833129, 0.008040379820742016], 0.007943282347242814: [0.0065522255590596545, 0.016194045089280462], 0.015848931924611134: [0.012111059426292314, 0.03289045081495423], 0.03162277660168379: [0.024359202379581224, 0.06774537459839003], 0.0630957344480193: [0.04632106116108725, 0.1421807978674262], 0.12589254117941676: [0.09469098741272519, 0.30104615205841967], 0.25118864315095796: [0.20929448821277952, 0.6020829454405856], 0.501187233627272: [0.48730806763295853], 0.999: [0.9375]},
                # 'Int': {0.001: [0.8750000000043652], 0.001995262314968879: [0.8750000000044716, 0.8750000000690084], 0.003981071705534973: [0.8750000000078266, 0.8750000010884859], 0.007943282347242814: [0.8750000001128574, 0.8750000170873421], 0.015848931924611134: [0.8750000033675578, 0.875000265681888], 0.03162277660168379: [0.8750000051433401, 0.8750040516317886], 0.0630957344480193: [0.8750001022909015, 0.8750593812121678],0.12589254117941676: [0.8750019660023436, 0.8758004925688065], 0.25118864315095796: [0.8750263569726182, 0.8839573500031664], 0.501187233627272: [0.8757470704772243], 0.999: [0.9375]}
        }
        # bler = { 'Polar(0.1)': {0.001: [2.0930104921101922e-05], 0.001995262314968879: [4.170985086604517e-05, 8.304813753134965e-05],0.003981071705534973: [0.00010374382967748286, 0.0003284371599558966], 0.007943282347242814: [0.0003093936845051104, 0.0012903426820463082], 0.015848931924611134: [0.0010452374886334992, 0.005002828092101952], 0.03162277660168379: [0.0038025282255498283, 0.01888878413491335], 0.0630957344480193: [0.014334037680204914, 0.06760162311202733], 0.12589254117941676: [0.05184532653776541, 0.21701403305161693], 0.25118864315095796: [0.16909150572799436, 0.5580107458703938], 0.501187233627272: [0.4907785921994958], 0.999: [0.9375]}}

    return metric


def plot_ber(metric, N=8,k=4,e0=[],graph='BER'):
  utils.plot_BSC_BAC(f'{graph} Coding Mechanism N={N} k={k}',metric,k/N)
  # print(metric)

def main():
  N = int(sys.argv[1])
  k = int(sys.argv[2])

  if sys.argv[3] == 'BLER':
   graph = sys.argv[3]
   nb_pkts = 0
  else:
    graph = 'BER'
    nb_pkts = int(sys.argv[3])

  ################## \Python3\python.exe ber_bler_calculator.py 8 4 1000 saved
  ################## \Python3\python.exe ber_bler_calculator.py 8 4 BLER saved
  metric = read_ber_file(N, k)
  if sys.argv[4] =='saved':
    metric = saved_results(metric, N, k, graph)


  # uncoded(metric, k, nb_pkts, graph)
  #
  # polar_codes(metric, N, k, nb_pkts, graph)
  # bch_codes(metric, N, k, nb_pkts, graph)
  # linear_codes(metric, N, k, nb_pkts, graph)
  # # flip_codes(metric, N, k, nb_pkts, graph)
  #
  # linear_codes_mapping(metric, N, k, nb_pkts, graph)
  # polar_codes_mapping(metric, N, k, nb_pkts, graph)
  # integrated_scheme(metric, N, k, nb_pkts, graph)

  # polar_codes_NN(metric, N, k, nb_pkts, graph,'BAC')
  linear_codes_NN(metric, N, k, nb_pkts, graph,'BAC')
  # autoencoder_NN(metric, N, k, nb_pkts, graph,'BAC') # \Python3\python.exe ber_bler_calculator.py 8 4 200 saved BSC


  # write_ber_file(N,k,metric,nb_pkts)



  plot_ber(metric, N,k,e0,graph)

e0 = np.logspace(-3,0,15)
# e0 = np.linspace(0.001,1,15)
e0[len(e0)-1] = e0[len(e0)-1]-0.001
e1 = [t for t in e0 if t<=0.5]

def write_ber_file(N,k,metric,nb_pkts):
  file = open(f"data_({N},{k})_{nb_pkts}pkts.py", "w")
  print(str(metric))
  file.write(str(metric))
  # for channel in metric:
  #   file.write(str(channel)+"\n")
  #   for e0 in metric[channel]:
  #     file.write(str((e0, metric[channel][e0]))+"\n")
  file.close()

def read_ber_file(N,k):
  if (N == 16 or N == 8) and (k == 4):
    file = open(f"data_({N},{k})_100000pkts.txt", "r")
    all_BER = eval(file.read())
    BER = {}
    for a in ['Polar(0.1)','BKLC']: #List of codes you want to plot from file
      BER[a] = all_BER[a]
    file.close()
  else:
    BER = {}
  return BER

if __name__ == "__main__":
  main()




